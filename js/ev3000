#!/usr/bin/env node
/**
 * vim: filetype=javascript :
 */


var d = {
  list  : [],
  std   : {}
};

/**
 *  The outer main function.
 *
 *  Creates closure so nothing besides 'd' is at the outer-most scope
 */
var main = function() {

  var net         = require('net');
  var urlLib      = require('url');
  var sg          = require('./utils/sg');
  var _           = require('underscore');

  var listeners = {}, numListeners = 0;
  var results = {};
  var numResults = 0;

  sg.__run([
    function(next) {

      sg.Runner = function() {
        var self = this;
        var e = self.environment = {};

        var push = function(x) {
          d.list.push(x);
        };

        var queue = [];
        self.enqueue = function(script) {
          queue.push(script);
          dispatch();
        };

        var dispatch = function() {
          var script, m, lines, resultName, options = {};

          if (queue.length > 0) {

            numResults++;
            resultName = 'r_' + numResults;

            script = queue.shift().join('');
            lines = script.split('\n');
            if (lines && lines.length > 0 && (m = /^(\s*[a-z_][a-z0-9_]*)\s*:=\s*(.*)$/i.exec(lines[0]))) {
              resultName = m[1];
              lines[0] = m[2];
            }

            options.startTime = new Date();
            options.resultName = resultName;
            var result = self.exec(lines.join('\n'));
            return d.std.publishResult(result, options, function(err) {
              setImmediate(dispatch);
            });
          }
        };

        self.exec = function(script) {
          try {
            return {response: eval(script)};
          } catch(err) {
            return {error: err};
          }
        };
      };
      return next();
    },
    
    function(next) {
      d.std.publishResult = function(result, options, callback) {
        options.resultName = options.resultName || 'r_' + (++numResults);
        results[options.resultName] = result;

        var output = options.resultName + ':= ' + result.response;
        if (options.startTime && /^[0-9]+$/.exec(result.response)) {
          output += '  [' + (parseInt(result.response, 10) * 1000 / (new Date() - options.startTime)) + ']';
        }
        output += '\n';

        _.each(listeners, function(listener) {
          listener.write(output, 'utf8');
        });
        if (result.response !== 0) {
          console.log(d.std.port, '                                                    ' + output.replace(/\n/, ''), (new Date() - options.startTime) * 0.001);
        }

        return callback();
      };

      return next();
    }],

    /**
     *  The main function.
     *
     *  Create listening ports:
     *
     *  1. The 'normal' or 'main' port:  the one that raw JS is sent to.
     *  2. The output of 'publishing' port.  Results or other output is sent here.
     */
    function main2() {
      var ARGV        = sg.ARGV();
      var runner      = new sg.Runner();

      d.std.port      = parseInt(ARGV.port || 9432, 10);

      // ---------- Create the input port---------- 
      var server = net.createServer();
      server.on('connection', function(connection) {

        var chunks = [], length = 0;
        connection.on('data', function(chunk) {
          chunks.push(chunk);
          length += chunk.length;
        });

        connection.on('end', function() {
          d.std.enqueueScript(chunks);
          console.log(d.std.port, 'script: ' + length);
        });

      });

      d.std.enqueueScript = function(chunks) {
        runner.enqueue(chunks);
      };

      console.log('Listening on ' + d.std.port);
      server.listen(d.std.port);
      //server.listen('/tmp/ev3000_server');

      // ---------- Create the output publishing port---------- 
      var publish = net.createServer();
      publish.on('connection', function(connection) {

        var name;

        numListeners++;
        name = 'L' + numListeners;
        listeners[name] = connection;

        var disconnectListener = function() {
          delete listeners[name];
          console.log('Removing subscriber: ' + name);
        };

        connection.on('end', function() {
          disconnectListener();
        });

        connection.on('error', function() {
          disconnectListener();
        });

        console.log('New subscriber: ' + name);
      });

      d.std.publishPort = d.std.port + 1000;
      console.log('Publishing on ' + (d.std.publishPort));
      publish.listen(d.std.publishPort);
      //publish.listen('/tmp/ev3000_publish');

      // Stats
      var dumpStats = function() {
        console.error(_.map(d.std.rawList.strings, function(stringPool, index) {
            return _.keys(stringPool).length;
          }).join(', ')
        );

        setTimeout(dumpStats, 1000);
      };
      //dumpStats();

    }
  );
};

main();

